---
title: 컴퓨터 시스템과 운영체제 (명품_운영체제 Ch 02)
categories:
  - operating-system
date: 2025-01-17
root-url: ../
permalink: /categories/operating-system/2025/01/17
---
### 컴퓨터 시스템
- 컴퓨터 시스템은 `응용소프트웨어 층`, `운영체제 층`, `컴퓨터 하드웨어 층`으로 3가지 요소로 이루어져 있다

- 컴퓨터 하드웨어
	- CPU(Central Processing Unit)
		- 기계 명령을 실행하는 중앙처리 장치, 메모리에 적재된 프로그램을 실행
	- 메모리(Memory) 
		- CPU에 의해 실행되는 프로그램 코드와 데이터가 적재되는 공간
	- 캐시 메모리(Cache Memory) 
		- 현대 컴퓨터에서 CPU 내부에 존재하는 메모리(온 칩 캐시(on-chip cache))로 실행될 데이터를 메모리에서 복사하여 CPU가 읽어 실행할 수 있게 함
		- CPU와 메모리의 처리속도 차이로 인해 발생하는 CPU의 대기시간을 줄이기 위함
		- 용량이 매우 작기 때문에 복사되는 데이터는 극히 일부분임
	- 기타 장치들(Device)
		- 입출력 장치(키보드, 마우스, 네트워크 장치 등)와 저장 장치(디스크,SSD 등)들이 있음
	- 버스(Bus)
		- 컴퓨터 하드웨어들이 데이터를 주고받기 위해 디지털 신호가 지나다니는 통로
		- 목적에 따라 시스템, 입출력 버스로 나뉜다
		- 지나가는 신호에 따라 주소, 데이터, 제어 버스로 나뉜다
		- 시스템 버스(System bus) 
			- CPU, 캐시 메모리, 메모리 등 빠른 H/W 사이의 신호를 전송하기 위한 버스
		- 입출력 버스(I/O bus)
			- 상대적으로 느린 입출력 장치들로의 입출력 데이터를 전송하기 위한 버스

- 컴퓨터 시스템의 구성

![](/assets/images/posts_img/screen_capture%202025-01-14%2017.29.45.png)

@ 현대에는 CPU에 NorthBridge의 기능이 내장되고 PCH가 SouthBrige의 역할을 대체하면서 사라짐


### CPU와 메모리 관계
- CPU와 메모리 사이의 동작 방식
	- 특정 주소에서의 데이터 처리가 필요함 
	  -> CPU가 주소 버스를 통해 메모리에게 주소 전달하고 제어 버스를 통해 해당 작업의 종류에 따라 지시(읽기,쓰기) 
	  -> 메모리는 주소를 전달받고 지시에 따라 데이터 버스를 활용해 CPU에게 데이터 전달 혹은 새로운 데이터 저장
- 32비트 CPU란?
	- 32개의 주소선을 가진 CPU(각 1비트)
	- CPU가 액세스 할 수 있는 메모리의 범위는?
		- n = 주소선 갯수 일 때, 2^n 바이트
		- 2^32 바이트 = 4GB (2^32개의 주소 공간, 공간 하나당 1바이트, 2^30 바이트 = 1GB, 1GB x 2^2 = 4GB) 

##### CPU의 레지스터(Register)
- PC(Program Counter) : 다음에 실행할 기계 명령의 메모리 주소를 저장하는 레지스터
- IR(Instruction Register) : 실행하기 위해 메모리에서 읽어 온 명령이 저장된 레지스터
- SP(Stack Pointer) : 스택 영역의 꼭대기 메모리 주소를 저장하는 레지스터

##### 스택(Stack)
- 운영체제는 프로그램 실행 시 4개의 공간을 제공 (메모리 영역)
	- 코드공간
		- 프로그램 코드가 적재되는 메모리 공간
	- 데이터 공간
		- 전역 변수 적재
	- 힙(heap) 공간
		- 실행 중 동적 저장 데이터를 위함
	- 스택(stack) 공간
		- 함수 호출 시 매개변수, 지역 변수, 함수의 복귀 주소 등 저장

##### 컨텍스트(Context)
- 컨텍스트(문맥)란 프로그램이 실행중인 상태 자체를 말함
- 메모리와 CPU 레지스터에 저장됨

##### 컨텍스트 스위칭(Context Switching)
- 실행중인 프로그램의 컨텍스트를 저장해두고 다른 프로그램의 컨텍스트를 CPU로 옮기는 것
- 컨텍스트 정보들은 PCB에 저장되어있음

![](/assets/images/posts_img/screen_capture%202025-01-15%2022.32.25.png)


### 운영체제
하드웨어 자원을 관리하고, 응용 프로그램와 하드웨어 사이를 중재하는 인터페이스
- 컴퓨터 시스템의 계층 구조

![](/assets/images/posts_img/screen_capture%202025-01-15%2023.29.48.png)
- 계층 간의 독립성
	- 각각의 계층에서 작업이 진행될 때 다른 계층의 영향을 받지 않기 위해
	- 운영체제가 하드웨어를 독점적으로 관리하지 않으면
		- 응용프로그램이 다른 응용프로그램이 적재된 메모리를 덮어쓰거나, 생성한 파일을 삭제하거나, 커널이 적재된 메모리를 엑세스하거나.. 등등의 문제가 발생

- 기능
	- 프로세스와 스레드 관리
	- 메모리 관리
	- 파일, 파일 시스템 관리
	- 장치 관리
	- 사용자 인터페이스
	- 네트워킹
	- 보호 및 보안

- 구성 요소
	- 커널(Kernel)
		- 프로세스 관리, 메모리 관리, 저장장치 관리 등 운영체제의 핵심적인 기능을 모아놓은 부분
		- 부팅 후 메모리에 적재
		- 시스템 콜을 통해 응용프로그램과 상호작용
	- 인터페이스(Interface)
		- 대표적으로 GUI와 CLI가 있음
		- GUI
			- 그래픽 요소를 이용한 시스템과의 상호작용
			- ex) 아이콘, 파일탐색기, 제어판 등
		- CLI
			- 명령어를 통한 시스템과의 상호작용
			- CMD, Terminal 등
	- 시스템 콜(System call)
		- 커널과 응용프로그램 사이의 인터페이스
		- 응용프로그램에서 커널 코드를 직접 호출하는 것이 아닌 시스템 호출 함수를 통해 요청 ex) fork(), exit(), open(), write() 등
	- 인터럽트(Interrupt)
		- 커널과 하드웨어 사이의 인터페이스
		- 입/출력 장치 혹은 다른 예외황이 발생하여 처리가 필요할 때, CPU에게 알려 요청을 처리하는 코드(인터럽트 서비스 루틴(ISR))를 실행하도록 한다
	 - 드라이버(Driver)
		- 운영체제와 하드웨어들과의 통신을 위한 인터페이스를 담당하는 소프트웨어
![](/assets/images/posts_img/Pasted%20image%2020250116214947.png)


#### 사용자 공간과 커널 공간
운영체제는 CPU로 엑세스할 수 있는 전체 주소 공간을 `사용자 공간`과 `커널 공간`으로 분리하여 운영한다
- 사용자 공간(User Space)
	- 응용프로그램 적재, 변수 생성 등
	- 사용자 공간의 크기 = 응용프로그램의 최대 크기
- 커널 공간(Kernel Space)
	- 커널 모듈 적재, 커널 함수 실행 시 필요한 스택 공간 등

- 분리 이유
	- 응용프로그램으로부터 커널 코드와 데이터를 보호하기 위함
	- 시스템 호출을 통해서만 엑세스 가능

- 가상 주소 공간
	- 사용자, 커널 공간은 실제 메모리 공간이 아닌 가상 주소 공간이다
	- 응용프로그램마다 주소선 갯수와 운영체제에 따라 다른 크기의 사용자, 커널 공간이 존재하는 가상 주소 공간을 부여받는다
		- CPU의 MMU(Memory Management Unit)가 가상 주소를 실제 물리적 메모리 주소로 변환해 사용함
	- 사용자 공간은 프로그램의 고유 공간이며, 커널 공간은 다른 프로그램과 공유한다

![](/assets/images/posts_img/screen_capture%202025-01-17%2018.51.32.png)

##### 매핑 과정에 응용프로그램들의 주소 공간이 충돌하지 않을까?
- 가상 주소가 같은 번지로 같더라도 서로 다른 프로세스는 독립적으로 동작
- 응용프로그램은 사용자 공간을 커널 공간에 있는 고유한 `매핑 테이블`을 통해 물리 메모리 공간으로 매핑하여 사용한다.
- 커널 공간은 커널이 존재하는 동일한 물리주소로 매핑되기에 각각의 프로세스들은 포인터 형식으로 접근하여 하나의 커널 공간을 공유한다

![](/assets/images/posts_img/screen_capture%202025-01-17%2019.44.28.png)


#### CPU의 사용자 모드와 커널 모드
응용프로그램 코드는 사용자 모드에서 실행되고, 커널 코드는 커널 모드에서 실행된다
- 운영체제에 의해 프로그램 실행 시 사용자 모드로, 시스템 콜 사용 시 커널 모드로 전환
- 믿을 수 없는 응용프로그램 코드를 상대로 커널 코드와 데이터를 보호하기 위함
![](/assets/images/posts_img/screen_capture%202025-01-17%2020.49.06.png)

- 커널 모드로 전환이 일어나는 경우
	- 시스템 호출(System call)
		- 하드웨어와의 엑세스는 커널 코드를 통해서만 가능하기 때문
		- 시스템 콜이 끝나면 CPU의 기계 명령에 의해 사용자 모드로 변경
	- 인터럽트(Interrupt)
		- 인터럽트 서비스 루틴은 커널 공간에 있다
		-  인터럽트 발생 시 자동으로 커널 모드로 바뀌며 인터럽트 서비스 루틴을 실행

- 특권 명령
	- I/O 명령 
	- Halt 명령
	- 인터럽트 플래그 켜고 끄기 
	- 타이머 설정
	- 컨텍스트 스위칭


##### 커널은 프로세스가 아니다
커널은 시스템 관리 기능을 위한 함수와 데이터의 집합

- 프로세스
	- 사용자 모드에서 실행됨
	- 제한된 자원만 접근 가능
	- 각자의 가상 주소 공간을 사용
	- 교유한 스택이나 힙에 데이터를 저장
- 커널
	- 커널 모드에서 동작함
	- 모든 하드웨어 자원에 접근 가능
	- 물리 메모리의 커널 공간에서 실행
	- 스택이나 힙을 가지지 않음(프로세스가 커널 모드를 사용하기 위해서 만들어지는 스택은 커널 내에 할당됨)


##### 라이브러리(Library)
미리 함수들을 작성하여 컴파일하고 바이너리 형태로 만든 파일
- 사용자 모드에서 실행되며 사용자가 작성한 함수들과 함께 사용자 공간에 적재된다
- 표준 라이브러리
	- 같은 언어에 대해서 OS나 HW에 상관없이 이름과 사용법이 같음
- 시스템 호출 라이브러리(커널 API)
	- OS마다 다르다
	- 기계 명령을 이용해 시스템 호출을 일으켜 커널 함수를 실행함


#### 함수 호출과 시스템 호출
- 함수 호출의 과정
	- 같은 주소 공간의 한 함수가 다른 함수를 실행하는 것(시스템 호출 라이브러리 함수를 호출하는 것도 함수 호출이다)
	- 사용자 모드에서 실행됨
	- 과정 : 실행될 함수는 실행 후 돌아올 주소와 실행을 통해 전달할 매개변수 값들을 스택에 저장
	  -> 실행될 함수의 주소로 이동 후 코드 실행
	  -> 종료 후 함수를 호출한 주소로 돌아옴
- 시스템 호출의 과정
	- CPU모드를 커널 모드로 바꾸고 커널 공간의 정해진 주소에 있는 `시스템 호출 핸들러` 코드를 실행하는 것
	- 커널 모드에서 실행됨
	- 과정 : 응용프로그램에서 시스템 호출 라이브러리 함수를 실행(표준 라이브러리 함수를 통해 시스템 호출 라이브러리 함수를 호출 할 수도 있음)
	  -> 해당 함수가 시스템 호출 CPU 명령을 실행
	  -> 커널 모드로 전환되고 CPU의 모든 레지스터 값을 `커널 스택`에 저장하며 그 안에 존재하는 커널 함수의 `고유 ID(시스템 호출 번호)`가 `시스템 호출 핸들러`에게 전달 됨
	  -> 핸들러가 커널 내에 존재하는 `시스템 호출 표`에서 ID값을 인덱스로 하여 필요한 커널 함수의 주소를 찾아낸다
	  -> CPU가 핸들러를 통해 커널 함수를 실행
	  -> 작업이 종료되면 커널 스택에 저장해둔 레지스터 값들을 CPU 레지스터에 복귀시킨다
	  -> 호출 함수로 복귀하는 `기계 명령(sysret 등)`을 실행하고 사용자 모드로 전환되며 호출 함수 위치로 돌아간다.
	  -> 읽은 값을 호출한 함수에게 리턴한다

- 시스템 호출을 일으키는 기계명령
	- CPU마다 시스템 호출을 일으키는 기계 명령을 두고 있다
	- '시스템 호출 CPU 명령' 혹은 '트랩 명령'이라고 부른다

![](/assets/images/posts_img/screen_capture%202025-01-18%2015.28.18.png)


##### 시스템 호출의 비용
표준 라이브러리 함수를 통해 파일 읽기 vs 시스템 호출 라이브러리 함수를 통해 파일 읽기
- 표준 라이브러리 함수의 파일 읽기 과정
	- 표준 라이브러리 내에 입력 버퍼가 존재한다
	  -> 표준 라이브러리 함수가 버퍼를 확인하고, 시스템 호출 라이브러리 함수를 호출한다
	  -> 처음 시스템 호출 라이브러리 함수를 사용할 때 디스크 블록 크기 만큼 읽도록 요청한다
	  -> 시스템 호출 라이브러리 함수가 커널 함수에게 디스크 블록 크기 만큼 읽도록 요청한다
	  -> 커널 함수는 요청만큼 파일을 읽어 입력 버퍼에 저장한다
	  -> 이후 응용프로그램이 요청하는 데이터는 버퍼에서 즉시 제공한다(시스템 콜 X)
- 시스템 호출 라이브러리 함수의 파일 읽기 과정
	- 시스템 호출 라이브러리 함수를 통해 시스템 호출이 이루어짐
	  -> 커널 함수가 요청한 만큼 파일을 읽어 전달함
	  -> 다음 요청 때도 똑같은 과정으로 요청한 만큼 전달함
	  -> 요청할 때마다 시스템 콜

![](/assets/images/posts_img/screen_capture%202025-01-18%2017.41.23.png)

***총 정리***
- 사용자나 응용프로그램이 접근하는 공간은 모두 `가상 공간`이다
	- 매핑 테이블을 통해 실제 물리 메모리 공간의 주소로 매핑된다
- 하드웨어를 사용하는 모든 작업은 `커널`을 통해서 이루어진다
- 커널을 사용하기 위해서는 CPU가 `커널 모드`가 되어야 하고 커널 모드로의 전환은 `시스템 콜` 혹은 `인터럽트`가 발생해야 한다
- 커널을 사용한다는 것은 커널 공간을 구성하는 `커널 함수`를 사용하는 것이다
- 시스템 호출 과정을 이해하자