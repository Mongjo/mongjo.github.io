---
title: "[스프링] 오브젝트와 의존관계 (토비의 스프링 vol.1)"
excerpt: post description
categories:
  - Spring
date: 2024-07-04
root-url: ../
---

스프링
    - 자바를 기반으로 한 프레임워크로서, 자바의 본질인 객체지향 프로그래밍을 강조한다
    - 주로 오브젝트에 집중하며, 객체가 어떻게 생성되고, 다른 객체와 어떻게 상호작용하며, 설계되고 구현되어야 하는지에 대한 깊은 이해가 필요하다
    - 이러한 객체지향 설계와 구현을 강제하지 않지만, 효과적인 객체 사용과 개선 방법에 대해 명확한 가이드라인을 제공한다


# 1.1 초난감 DAO

- DAO(Data Access Object)
    - DB를 통한 데이터 조회와 조작을 담당하는 객체 (통신을 추상화하여 애플리케이션 코드와 데이터 접근 로직을 분리)
- 자바빈(JavaBean)
    - JSP페이지의 디자인 부분과 로직부분을 나눔으로써 재사용성을 증가시키는 기능의 형태
    - 현재에는 아래와 같은 규약에 따라 만들어지는 오브젝트를 가리킨다
	    - 기본 생성자 : 자바빈은 아무런 인자를 받지 않는 기본 생성자를 가져아한다 -> 자바빈은 툴이나 프레임워크에서 리플렉션을 이용하여 객체를 생성하기 때문 
		    -리플렉션(Reflection) : 클래스, 메서드, 필드 등을 런타임에서 동적으로 검사하고 조작 할 수 있는 기능
	    - 프로퍼티 : 멤버변수의 접근제어자는 private, 클래스와 set/get 메소드의 접근제어자는 public이며 set/get 메소드를 이용해 프로퍼티에 접근할 수 있다

- UserDao
    ```java
    import java.sql.*;
    
    public class UserDao {
        public void add(User user) throws ClassNotFoundException, SQLException {
            Class.forName("com.mysql.jdbc.Driver");
            Connection c = DriverManager.getConnection(
                    "jdbc：mysql：//localhost", "spring", "book");
    
            PreparedStatement ps = c.prepareStatement(
                    "insert into users(id, name, password) values(?,?,?)");
            ps.setString(1, user.getId());
            ps.setString(2, user.getName());
            ps.setString(3, user.getPassword());
    
            ps.executeUpdate();
    
            ps.close();
            c.close();
        }
            public User get(String id) throws ClassNotFoundException, SQLException {
                Class.forName("com.mysql.jdbc.Driver");
                Connection c = DriverManager.getConnection(
                        "jdbc：mysql：//localhost", "root", "2092");
    
                PreparedStatement ps = c.prepareStatement(
                        "select * from users where id = ?");
                ps.setString(1, id);
    
                ResultSet rs = ps.executeQuery();
                rs.next();
                User user = new User();
                user.setId(rs.getString("id"));
                user.setName(rs.getString("name"));
                user.setPassword(rs.getString("password"));
    
                rs.close();
                ps.close();
                c.close();
    
                return user;
        }
    }
    ```
    

# 1.2 DAO의 분리

객체지향 기술은 가상의 추상세계 자체를 효과적으로 구성할 수 있고, 이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있는 기술적 특징 때문에 좀 더 번거로운 작업을 요구한다

객체를 설계할 때 가장 염두에 둬야 할 사항은 미래의 변화(요구사항, 운영 환경의 변화)에 대한 대비이다

- 분리와 확장
    - 변화는 대체로 집중된 한 가지 관심에 대해 일어난다
    - 특정 작업으로 인해 관심이 다른 부분까지 영향을 받으면 안된다

### 관심사의 분리
- 관심이 같은 것끼리는 하나의 객체 혹은 친한 객체로
- 관심이 다른 것은 가능한 떨어져 영향을 주지 않도록

- UserDao의 관심사항
    1. DB와 연결을 위한 커넥션을 어떻게 가져올까
    2. DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것
    3. 작업이 끝나면 Statement와 Connection객체를 닫아줘서 시스템에 반환

- UserDao의 문제점
    1. DB 커넥션을 가져오는 코드가 다른 관심사와 섞여 add() 메소드에 담겨 있다
    2. 동일한 코드가 get() 메소드에도 중복되어 있다 -> 이후에 수많은 DAO 메소드를 만들게 되면 같은 코드가 계속 중복되어 나타날 것이다

- 중복 코드의 메소드 추출
	- 중복 코드를 독립적인 메소드로 만들어둔다
	
- 중복을 제거한 UserDao
    ```java
    public void add(User user) throws ClassNotFoundException, SQLException {
	    Connection c = getConnection();
	    ...
    }
    
	public void get(String id) throws ClassNotFoundException, SQLException {
	    Connection c = getConnection();
	    ...
    }

	private Connection getConnection() throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection(
			"jdbc:mysql://localhost/springbook", "spring", "book");
		return c;
	}
    ```
    
- 변경점
	1. 특정 관심사에 대한 변경이 일어날 경우 그 관심이 집중되는 부분의 코드만 수정하면 된다
	2. 관심이 다른 코드에는 영향을 주지도 않고 독립적으로 존재한다

이렇게 기능과 실행 결과의 변화 없이 코드의 구조를 재조정하는 작업을 리팩토링(refactoring)이라고 하며, 위의 상황처럼 중복된 코드를 하나의 메소드로 뽑아내는 것을 리팩토링에서는 메소드 추출(extract method)기법이라고 한다

### 상속을 통한 확장
UserDao를 판매한다고 할 때 소스코드가 아닌 미리 컴파일된 클래스 바이너리 파일만 제공하면서 고객 스스로 원하는 DB 커넥션 생성 방식을 적용하게 하는 등 지속적인 변경에 자유롭게 할 수 있을까?
	- getConnection()을 추상 메소드로 만든다
	- 이후 고객들은 UserDao 클래스를 상속하여 서브클래스를 만들고 원하는 방식대로 getConnection() 메소드를 구현한다

- 상속을 통한 확장 UserDao
    ```java
    public void add(User user) throws ClassNotFoundException, SQLException {
	    Connection c = getConnection();
	    ...
    }
    
	public void get(String id) throws ClassNotFoundException, SQLException {
	    Connection c = getConnection();
	    ...
    }

	private Connection getConnection() throws ClassNotFoundException, SQLException {
		/* 구현 코드가 제거된 추상메소드 */
		/* 구현은 서브클래스가 담당 */
	}

	public class NUserDao extends UserDao { 
		public Connection getConnection() throws ClassNotFoundException, SQLException {
			/* N 사 DB connection 생성코드 */
		}
	}
	
	public class DUserDao extends UserDao {
		public Connection getConnection() throws ClassNotFoundException, SQLException {
		    /* D 사 DB connection 생성코드 */
		}
	}
    ```
    - 이런식으로 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩 가능한 protected 메소드 등으로 만든 뒤 서브 클래스에서 구현하여 사용하도록 하는 방법을 디자인 패턴에서 템플릿 메소드 패턴(template method pattern)이라고 한다
    - 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것은 팩토리 메소드 패턴(factory method pattern)이라 부른다

- 디자인 패턴
	- 소프트웨어 설계 시 발생하는 반복적인 문제들에 대한 해결책 중에서 많은 사람들이 인정한 모범 사례
- 템플릿 메소드 패턴(template method pattern)
	-상속을 통한 확장을 사용할 때 가장 대표적인 방법
	-변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다
-  예시
    ```java
    public abstract class Super {
	    public void templateMethod() {
		    //기본 알고리즘 코드
		    hookMethod();
		    abstractMethod();
		    ...
	    }
	    protected void hookMethod() { }  /* 선택적으로 오버라이드 가능한 훅 메소드 */
	    public abstract void abstractMethod(); /* 서브클래스에서 반드시 구현해야 하는 추상 메소드 */
    }

	public class Sub1 extends Super { /* 슈퍼클래스의 메소드를 오버라이드하거나 구현하여 기능 확장 */
		protected void hookMethod(){
			...
		}
		public void abstractMethod() {
			...
		}
	}
    ```
    
- 팩토리 메소드 패턴(factory method pattern)
	-상속을 통한 확장패턴이기에 템플릿 메소드 패턴과 비슷한 구조
	-객체 생성의 책임을 서브클래스에 위임함으로써 객체 생성 코드를 캡슐화하고 코드의 유연성과 확장성을 높이는 디자인 패턴
-  예시
    ```java
    // Product Interface
	public interface Car {
	    void drive();
	}
	
	// Concrete Product Classes
	public class Sedan implements Car {
	    @Override
	    public void drive() {
	        System.out.println("Driving a sedan");
	    }
	}
	
	public class SUV implements Car {
	    @Override
	    public void drive() {
	        System.out.println("Driving an SUV");
	    }
	}
	
	// Factory Class
	public abstract class CarFactory {
	    public abstract Car createCar();
	
	    public void driveCar() {
	        Car car = createCar();
	        car.drive();
	    }
	}
	
	public class SedanFactory extends CarFactory {
	    @Override
	    public Car createCar() {
	        return new Sedan();
	    }
	}
	
	public class SUVFactory extends CarFactory {
	    @Override
	    public Car createCar() {
	        return new SUV();
	    }
	}
	
	// Client Code
	public class Client {
	    public static void main(String[] args) {
	        CarFactory sedanFactory = new SedanFactory();
	        CarFactory suvFactory = new SUVFactory();
	
	        sedanFactory.driveCar(); // Output: Driving a sedan
	        suvFactory.driveCar(); // Output: Driving an SUV
	    }
	}

    ``` 

- 차이점 : 템플릿 메소드 패턴은 알고리즘의 구조를 정의하고 세부 구현을 서브클래스에 위임하는 반면, 팩토리 메소드 패턴은 객체 생성의 책임을 서브클래스에 위임하여 객체 생성 코드를 캡슐화한다

- 상속을 통한 확장의 단점
	- 자바는 클래스의 다중상속을 허용하지 않는다
		-만약 UserDao가 이미 다른 목적을 위해 상속을 사용하고 있다면 문제가 된다(새로운 상속구조로 만들어도 후에 다른 목적으로 상속을 적용하기 힘들다)
	- 상속을 통한 상하위 클래스의 관계가 밀접하다 (관심이 다른 기능을 분리하고, 확장성도 좋지만 여전히 상속관계는 긴밀한 결합을 허용한다)
	- 확장 기능을 다른 클래스에 적용할 수 없다(코드 중복)


# 1.3 DAO의 확장
관심들은 변화의 성격이 다르다
변화의 성격이 다르다는 것은 이유와 시기, 주기 등이 다르다는 것이다
위에서는 변화의 성격이 다른 것을 분리해서, 서로 영향을 주지 않은 채로 필요한 시점에 독립적으로 변경할 수 있게 하기 위해 추상 클래스를 만들고 서브클래스에서 상속하게 하였다

### 클래스의 분리
이때까지 했던 독립 메소드를 통한 분리, 상하위 클래스로 분리가 아닌 완전한 독립 클래스로 분리한다
DB 커넥션과 관련된 부분을 아예 별도의 클래스에 담고 UserDao가 이용하게 한다
-  독립된 DB 커넥션 기능을 하는 클래스
    ```java
    public class SimpleConnectionMaker {
	    public Connection makeNewConnection() throws ClassNotFoundException, SQLException {
			Class.forName("com.mysql.jdbc.Driver");
			Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
			return c;
		}
    }
    ```
-  바뀐 UserDao
    ```java
    public class UserDao {
		private SimpleConnectionMaker SimpleConnectionMaker;
		
		public UserDao() {
		SimpleConnectionMaker = new SimpleConnectionMaker();
		}
		public void add(User user) throws ClassNotFoundException, SQLException {
			Connection c = SimpleConnectionMaker.makeNewConnection();
			...
		}
		public void get(String id) throws ClassNotFoundException, SQLException {
			Connection c = SimpleConnectionMaker.makeNewConnection();
			...
		}
	}
    ```

그러나 UserDao의 코드가 특정 클래스에 종속되어 있기 때문에 상속을 통한 확장으로 해결했던 문제점으로 다시 돌아오게 되었다

### 인터페이스의 도입
인터페이스 : 다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지 담당하는 일종의 추상 클래스

인터페이스에는 구현 방법은 나타나 있지 않고 구현하는 클래스들이 결정할 일이다
- ConnectionMaker 인터페이스
    ```java
    package springbook.user.dao；

	public interface ConnectionMaker {
	
		public Connection makeConnection() throws ClassNotFoundException, SQLException;
	}
    ```
고객들은 ConnectionMaker 인터페이스를 구현한 클래스를 만들고 메소드를 작성해주면 된다
- 구현 클래스
    ```java
    package springbook.user.dao；

	public class DConnectionMaker implements ConnectionMaker {
		@Override
		public Connection makeConnection() throws ClassNotFoundException, SQLException {
			// 고객의 방법으로 Connection을 생성하는 코드
		}
	}
    ```
-  바뀐 UserDao
    ```java
    public class UserDao {
		private ConnectionMaker ConnectionMaker;
		
		public UserDao() {
			ConnectionMaker = new DConnectionMaker();
		}
		public void add(User user) throws ClassNotFoundException, SQLException {
			Connection c = ConnectionMaker.makeConnection();
			...
		}
		public void get(String id) throws ClassNotFoundException, SQLException {
			Connection c = ConnectionMaker.makeConnection();
			...
		}
	}
    ```  
그러나 생성자 코드에 인터페이스를 구현한 클래스의 이름이 나타난다(여전히 사용할 구현 클래스의 정보를 알아야 하기에 종속된 상황)

### 관계설정 책임의 분리
사용할 구현 클래스의 이름을 알아야 한다는 것은 UserDao와 UserDao가 사용할 특정 구현 클래스 사이의 관계를 설정하주는 것에 관한 관심이다
이 관심을 담은 코드를 분리하지 않으면 독립적으로 확장 가능한 클래스가 될 수 없다

UserDao의 클라이언트에서  UserDao를 사용하기 전에, UserDao가 어떤 구현 클래스를 사용할지를 결정하도록 하자

UserDao에서 사용할 클래스 즉 오브젝트를 UserDao의 코드 내에서 만들 필요는 없다
메소드 파라미터나 생성자 파라미터를 이용하자
- 수정된 생성자 코드
    ```java
    public UserDao(ConnectionMaker connectionMaker) {
		this.connectionMaker = connectionMaker;
	}
    ```  
UserDao에는 더이상 다른 관심사항, 책임이 없다 

### 원칙과 패턴
- 개방 폐쇄 원칙
	-클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다

- 응집도와 결합도
	-응집도 : 모듈 내부의 기능적인 집중 정도
	-결합도 : 모듈과 모듈 사이의 의존 정도

- 높은 응집도와 낮은 결합도
	-응집도가 낮다면 변경이 필요할 때 필요한 부분을 찾아내는 것도, 변경한 것이 다른 기능에 영향을 주는지도 확인해야한다
	-결합도가 높다면 하나의 오브젝트가 변경이 일어날 때 관계를 맺는 다른 오브젝트에게도 변경에 대한 요구가 전파된다
	- 응집도가 높을수록 결합도가 낮을수록 좋다

- 전략 패턴
	객체들이 할 수 있는 행위 각각에 대해 전략 클래스를 생성하고, 유사한 행위들을 캡슐화 하는 인터페이스를 정의하여, 객체의 행위를 동적으로 바꾸고 싶은 경우 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는 디자인 패턴

- 전략 패턴의 구성 요소
	-Context: 기능을 수행하는 데 필요한 알고리즘을 외부에서 주입받아 사용
	-Strategy Interface: 알고리즘을 정의하는 인터페이스
	-Concrete Strategy: 알고리즘을 구체적으로 구현한 클래스

- UserDao의 전략 패턴
	-UserDao : Context
	-ConnectionMaker : Strategy Interface
	-DConnectionMaker : 고객들의 방식대로 구현한 클래스(Concrete Strategy)


# 1.4 제어의 역전
객체의 생성 방법을 결정하고 그렇게 만들어진 객체를 돌려주는 오브젝트를 팩토리라고 한다

- DaoFactory
    ```java
    package springbook.user.dao;
    ...
	public class DaoFactory { 
		public UserDao userDao() {
			ConnectionMaker connectionMaker = new DConnectionMaker();
			UserDao userDao = new UserDao(connectionMaker);
			
			return userDao;
		}
	}
    ```  
