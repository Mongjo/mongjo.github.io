---
title: "[운영체제] Chap09.페이징 메모리 관리"
excerpt: 

categories:
  - 운영체제
tags:
  - []

permalink: 

date: 2024-06-05
last_modified_at: 2024-06-07

typora-root-url: ../
---

## 1. 페이징 메모리 관리 개요



### 1.1 페이징 개념

- 프로세스의 주소 공간을 0번지부터 `페이지`로 불리는 고정 크기로 나누고 물리 메모리 역시 페이지와 동일한 크기로 분할하여, 프로세스의 각 페이지를 물리 메모리의 임의의 페이지에 분산 할당하는 기법
- MMU 장치는 페이지 테이블을 이용하여 논리 주소를 물리 주소로 변환
- 페이지의 크기는 시스템에 따라 4KB, 8KB, 16MB 등으로 설정됨

![screenshot-7656727](/assets/images/posts_img/2024-06-06-chap09-paging-memory-management/screenshot-7656727.png)

### 1.2 페이징의 우수성

- 구현이 쉽다(easy).
  - 페이징은 메모리를 0번지부터 고정 크기의 페이지로 분할하기 때문에 이해하기 쉽고 구현하기 쉽다.
- 이식성이 높다(portable).
  - 페이징은 CPU에 의존적이지 않기 때문에 다양한 시스템에 동일한 방식으로 쉽게 구현 가능하다.
- 융통성이 높다(flexible).
  - 외부 단편화가 없고 홀 선택 알고리즘을 실행할 필요가 없어 메모리 활용과 오버헤드 면에서 우수
  - 내부 단편화가 발생하지만, 그 크기는 매우 작다.



### 페이지 테이블

![screenshot-7657311](/assets/images/posts_img/2024-06-06-chap09-paging-memory-management/screenshot-7657311.png)

페이지의 크기가 4KB일 때, 현재 이 프로세스는 사용자 공간에서 6개의 페이지를 사용하고 있으므로 프로세스의 크기는 약 4KBx6 = 24KB



#### 프로세스가 동적 할당 받을 때

프로세스의 힙과 스택 영역은 프로세스의 실행 중에 페이지가 생기기도 소멸되기도 한다.

<p><font color=red>그림 9-2</font>의 상황에서 프로세스가 200 byte를 동적 할당받는 코드를 실행한다고 하자.</p>

```c
char *p (char*)malloc(200); // 프로세스의 힙 영역에서 200 byte 동적 할당 
```

1. 프로세스의 힙 영역에 페이지 5를 할당(페이지 4를 모두 사용하고 있다고 가정)
2. 비어 있는 물리 프레임 2를 할당
3. 프로세스 페이지 테이블의 항목 5에 프레임 번호 2를 기록

![screenshot-7658033](/assets/images/posts_img/2024-06-06-chap09-paging-memory-management/screenshot-7658033.png)

4. 페이지 5의 앞 200 byte를 malloc(200)의 요청 결과로 할당

   - malloc(200) 함수는 페이지 번호 5의 논리 주소인 4KB*5 = 20480을 리턴하여 포인터 변수 p에 저장

     ```c
     *p = 'a'; // 페이지 5에 문자 'a' 기록
     ```

     CPU는 논리 주소 20480 번지에 'a'를 저장하는 것으로 실행하지만, 실제로는 MMU에 의해 논리 주소 20480이 물리 주소 8192로 바뀌어 물리 메모리 8192 번지에 'a'가 저장된다.

     ```c
     free(p);
     ```

     페이지 5 내에 할당된 200 byte가 반환되는데, 반환 후 페이지 5 전체가 비게 되므로 페이지 5와 프레임 2가 모두 반환되어 다음 물리 메모리 할당 시에 사용될 것이다. 또한 페이지 테이블의 항목 5에 `null`이 기록된다.

     

#### 프로세스의 함수들이 호출될 때

프로세스의 스택 영역의 s-1번 페이지가 함수의 스택으로 추가 활용되고 이 페이지를 적재할 물리 프레임이 할당된다. 그리고 페이지 테이블의 s-1번째 항목에 프레임 번호가 기록된다.



#### 시스템 호출시 프로세스의 페이지 테이블 활용

프로세스 주소 공간 중 커널 페이지들을 물리 프레임에 매핑하는 프로세스 테이블 항목들을 볼 수 있다. 프로세스의 주소 공간에서 커널 페이지가 활용되는 경우는 프로세스가 `시스템 호출`을 실행하는 경우이다.

![screenshot-7661651](/assets/images/posts_img/2024-06-06-chap09-paging-memory-management/screenshot-7661651.png)

커널 코드도 논리 주소로 되어 있으며, 시스템 호출을 통해 커널 코드가 실행될 때 현재 프로세스의 페이지 테이블을 이용하여 물리 주소로 변환된다.



## 2. 페이징의 주소 체계



### 2.1 페이징의 논리 주소

```
논리 주소 = [ 페이지 번호(p), 오프셋(offset) ] *offset: 페이지 내에서의 상대 주소
```

![screenshot-7662634](/assets/images/posts_img/2024-06-06-chap09-paging-memory-management/screenshot-7662634.png)

> 논리 주소 0x12345678은 몇 번째 페이지의 몇 번째 바이트에 대한 주소일까?
> **0x12345**번 페이지의 **0x678**번째 바이트에 대한 주소이다.



### 2.2 논리 주소의 물리 주소 변환

![screenshot-7662964](/assets/images/posts_img/2024-06-06-chap09-paging-memory-management/screenshot-7662964.png)

페이지 번호 p를 프레임 번호 f로 바꾸로 오프셋을 그대로 사용하면 논리 주소를 물리 주소로 바꿀 수 있다.



### 2.3 페이징 구현

페이징 기법이 컴퓨터 시스템에 구현되기 위해서는 CPU, MMU, 운영체제의 공동 지원이 있어야 한다.

#### 하드웨어 지원

- PTBR(Page Table Base Register) 레지스터 필요
  - 현재 실행 중인 프로세스의 페이지 테이블이 적재된 물리 메모리 주소 저장
- MMU 장치 CPU 칩에 패키징

#### 운영체제 지원

- 운영체제는 물리 메모리의 빈 프레임 리스트를 생성하고 관리 유지하여, 메모리 프레임을 동적으로 할당/반환하는 기능
- 페이지 테이블을 관리하는 기능
- 각 프로세스마다 페이지 테이블이 적재된 물리 메모리 주소를 PCB에 저장



## 3. 페이지 테이블의 문제점과 TLB



### 3.1 페이지 테이블의 문제점

페이지 테이블로 인한 성능 저하와 공간 낭비의 2가지 문제가 있다.

- 성능 저하

  - 페이지 테이블은 크기가 크기 때문에 CPU 칩 내에 둘 수 없고 메모리에 둔다. CPU가 메모리를 액세스할 때마다 페이지 테이블 액세스 1번, 데이터의 물리 메모리 액세스 1번으로, **물리 메모리를 2번 액세스**하여 프로세스의 실행 속도를 심각하게 저하

    ```
    메모리 액세스 = 페이지 테이블 항목 읽기 1번 + 데이터 액세스 1번
    ```

![screenshot-7663903](/assets/images/posts_img/2024-06-06-chap09-paging-memory-management/screenshot-7663903.png)

- 공간 낭비
  - 페이지 테이블의 크기는 프로세스의 최대 크기(주소 공간)에 맞추어 생성되지만, 실제 프로세스의 크기는 그에 못 미치기 때문에, 페이지 테이블의 많은 항목들이 사용되지 않는 채 비어 있어 메모리 낭비



### 3.3 TLB를 이용한 2번의 물리 메모리 액세스 문제 해결

논리 주소를 물리 주소로 바꾸는 과정에서 페이지 테이블을 읽어 오는 과정을 없앤다면 프로그램의 실행 속도를 획기적으로 높일 수 있다.



#### TLB

TLB(Translation Look-aside Buffer)는 **MMU 내에 두는 것**으로 CPU가 최근에 액세스한 `페이지 번호와 페이지가 적재된 프레임 번호의 쌍`을 저장하는 캐시 메모리이다.

```
TLB의 항목 = [ 페이지 번호 p, 프레임 번호 f ]
```

![screenshot-7664846](/assets/images/posts_img/2024-06-06-chap09-paging-memory-management/screenshot-7664846.png)

TLB는 논리 주소에 담긴 페이지 번호를 TLB 내의 각 항목에 걸쳐 하나씩 순차적으로 비교하지 않고, **모든 항목과 동시에 비교**하여 단번에 프레임 번호를 출력한다.

현재 상용 CPU 내에 사용되는 TLB의 경우, 항목의 개수가 64~1024개 정도로 작은 편이다. 크기가 작기 때문에 최근에 액세스한 소수의 `페이지와 프레임`의 번호를 저장하여 TLB의 활용성을 높인다.

![screenshot-7665317](/assets/images/posts_img/2024-06-06-chap09-paging-memory-management/screenshot-7665317.png)



#### TLB와 참조의 지역성

TLB를 사용한다고 모든 프로그램의 실행 속도가 개선되는 것은 아니다. 프로그램의 메모리 액세스 패턴에 따라 실행 속도가 달라진다. TLB는 **순차 메모리 액세스 패턴**을 가진 프로그램에게 매우 효과적이다.

> 프로그램은 실행되는 동안 짧은 시간 범위 내에 일정 구간의 메모리 영역(동일한 페이지나 바로 이전 페이지 등)을 **반복 액세스**하는 경향이 있다. 이 경향성을 **참조의 지역성**이라고 한다.

참조의 지역성으로 인해 작은 크기의 TLB에서도 히트 적중률을 기대할 수 있고, 성능 개선이 가능하다.

하지만, 프로그램이 **랜덤하게 메모리를 액세스**할 경우, 참조의 지역성이 잘 형성되지 않기 때문에 TLB 미스가 자주 발생하고 성능 향상은 크지 않다.



#### TLB를 고려한 컨텍스트 스위칭 재정립

TLB를 이용하는 시스템에서 CPU 스케줄링 결과 동일한 프로세스의 다른 스레드가 실행된다면, TLB에 들어있는 항목들이 교체될 필요는 없다. 동일한 프로세스의 주소 공간에서 실행되므로 동일한 페이지 테이블이 사용되기 때문이다.

하지만, 다른 프로세스의 스레드로 컨텍스트 스위칭되는 경우 TLB도 새로운 프로세스의 페이지 테이블 항목들로 교체되어야 한다. 컨텍스트 스위칭 과정은 TLB를 고려하여 다시 정리되어야 한다.

1. CPU의 모든 레지스터들을 TCB에 저장
2. 새 프로세스의 PCB에 저장된 페이지 테이블 주소를 PTBR에 적재
3. TLB 캐시의 모든 항목 삭제
4. 새로 스케줄된 스레드의 컨텍스트를 레지스터에 적재 후 실행
   - TLB 캐시를 비운 채 실행되면, TLB 미스가 계속 발생
   - 얼마 지나지 않아 TLB 캐시는 새 스레드가 액세스한 페이지 번호와 프레임 번호들로 채워짐



## 4. 페이지 테이블의 낭비 문제 해결



### 4.1 페이지 테이블의 메모리 낭비

페이지 테이블로 인해 메모리가 낭비되는 데는 다음 2가지 요인이 있다.

- 페이지 테이블의 일부 항목만 사용
- 프로세스마다 페이지 테이블 존재



페이지 테이블로 인한 메모리 낭비를 줄이는 다양한 방법이 연구되었는데 대표적으로 다음 2가지 방법이 있다.

- 역 페이지 테이블(IPT, Inverted Page Table)
- 멀티레벨 페이지 테이블(mulit-level page table)



### 4.2 역 페이지 테이블

기존의 페이지 테이블이 프로세스를 중심으로 프로세스의 각 페이지가 적재된 프레임 번호를 저장하는 방식이었다면, **역 페이지 테이블**은 프레임을 중심으로 물리 메모리의 전체 프레임에 대해 각 프레임이 어떤 프로세스의 어떤 페이지에 할당되었는지 나타내는 테이블로 **시스템에 1개만 둔다.**

```
역 페이지 테이블의 항목 = [ 프로세스 번호(pid), 페이지 번호 p ]
```

![screenshot-7667030](/assets/images/posts_img/2024-06-06-chap09-paging-memory-management/screenshot-7667030.png)

물리 메모리가 n개의 프레임으로 구성될 때 역 페이지 테이블의 항목 개수도 n개로 구성된다.



#### 논리 주소의 물리 주소로의 변환

```
논리 주소 = [ 프로세스 번호(pid), 페이지 번호 p, 오프셋 offset ]
```

![screenshot-7667218](/assets/images/posts_img/2024-06-06-chap09-paging-memory-management/screenshot-7667218.png)

논리 주소가 발생되면 MMU는 PID와 p로 역 페이지 테이블을 검색하여 일치하는 항목을 찾는다. 항목이 발견되면, 항목 번호가 바로 프레임 번호이므로, 발견된 프레임 번호(f)와 오프셋(offset)을 연결하여 물리 주소로 변환한다. PTBR(Page Table Buffer Register)에 역 페이지 테이블의 위치를 저장해둔다.



> 주소 변환 시 역 페이지 테이블 항목을 처음부터 하나씩 비교하여 일치하는 항목을 찾는 방식을 선형 역 페이지 테이블(linear inverted page table)이라 한다. 이 방식은 비교에 많은 시간이 걸리는 단점이 있다. 역 페이지 테이블을 해시 테이블로 만들고 해시 함수를 이용하여 'pid와 p'를 해싱하여 단번에 일치시키는 항목을 찾는 해시 역 페이지 테이블(hashed inverted page table)도 있다.



### 4.3 멀티레벨 페이지 테이블

멀티레벨 페이지 테이블은 프로세스가 현재 사용 중인 페이지들에서 대해서만 페이지 테이블을 만드는 방식으로 페이지 테이블의 낭비를 줄인다. 페이지 테이블을 작은 페이지 테이블로 나누고 이들을 계층적으로 구성하는 방법이다.



#### 2-레벨 페이지 테이블 개요

<p><font color=red>그림 9-16</font>은 현재 프로세스에게 할당된 페이지들에 대해서만 페이지 테이블이 만들어진 사례로 3개의 페이지 테이블이 만들어져 있다.</p>

![screenshot-7667807](/assets/images/posts_img/2024-06-06-chap09-paging-memory-management/screenshot-7667807.png)

프로세스가 현재 할당받지 않은 페이지들에 대해서는 페이지 테이블을 만들지 않음으로써 불필요한 페이지 테이블의 크기를 줄인다. 페이지 테이블의 한 항목을 4byte로 만들면, 1개의 페이지 테이블은 4byte x 1024 = 4KB로 1개의 프레임에 딱 저장 가능한 크기이다. 이것은 1개의 페이지 테이블을 1개의 프레임에 저장하기 위해 의도적으로 설계한 것이다.

이것으로 2-레벨 페이지 테이블이 완성된 것은 아니다. 페이지 테이블이 메모리에 저장되므로 각 페이지 테이블이 저장된 프레임의 번호를 기억하는 다른 테이블이 필요한데 이를 **페이지 디렉터리(page directory)**라고 부른다.

![screenshot-7668548](/assets/images/posts_img/2024-06-06-chap09-paging-memory-management/screenshot-7668548.png)

페이지 디렉터리의 크기 역시 4KB로 1개의 프레임에 딱 맞게 저장된다. 페이지 디렉터리의 각 항목에는 순서대로 페이지 테이블이 저장된 프레임의 번호가 기록된다.

<font color=red>그림 9-17</font>를 보면, 페이지 2에 저장된 코드나 데이터를 액세스하려면 페이지 디렉터리가 물리 메모리에서 읽혀지고, 페이지 디렉토리의 첫 번째 항목에서 페이지 테이블 1이 저장된 프레임 번호를 알아낸 후 메모리에서 페이지 테이블 1을 읽어 들이고, 페이지 테이블의 항목 2에서 페이지가 저장된 물리 프레임을 알아낸다. 페이지 디렉터리와 페이지 테이블의 2단계 과정을 거치기 때문에 2-레벨 페이지 테이블이라고 부른다.



#### 2-레벨 페이지 테이블의 구성

페이지 디렉터리와 페이지 테이블들이 2단으로 연결되므로, 논리 주소의 페이지 번호 부분이 [페이지 디렉터리 인덱스, 페이지 테이블 인덱스]로 나누어져 논리 주소는 다음과 같이 3개의 요소로 구성된다.

```
논리 주소 = [ 페이지 디렉터리 인덱스, 페이지 테이블 인덱스, offset ]
```

![screenshot-7669223](/assets/images/posts_img/2024-06-06-chap09-paging-memory-management/screenshot-7669223.png)



#### 2-레벨 페이지 테이블에서 논리 주소의 물리 주소 변환 과정

CPU에는 페이지 디렉터리가 저장된 물리 메모리의 주소를 저장하는 레지스터가 있으며, 프로세스가 스케줄링될 때 PCB로부터 페이지 디렉터리가 저장된 물리 주소가 이 레지스터에 적재된다.

1. `페이지 디렉터리 인덱스`가 가리키는 페이지 디렉터리 항목을 읽고, 페이지 테이블의 프레임 번호를 알아낸다. 그리고 페이지 테이블을 물리 메모리로 읽어 들인다.
2. `페이지 테이블 인덱스`가 가리키는 페이지 테이블의 항목에 읽고, 저장된 프레임 번호(f)를 읽는다. 이 값이 바로 액세스하려는 페이지가 저장된 프레임 번호이다.
3. MMU는 이 프레임 번호(f)와 offset을 결합하여 물리 주소를 완성한다.



> 멀티레벨 페이지 테이블은 Windows나 리눅스 등 대부분의 운영체제에서 실제 사용되고 있다. CPU나 운영체제 버전에 따라 3-레벨, 4-레벨, 5-레벨까지 페이지 테이블로 구축하여 사용하고 있다.





